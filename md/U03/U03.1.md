theme: benigaslo
class: lead

---

# Arrays
### Unidad 3.1
![cc.png](https://gvaedu-my.sharepoint.com/personal/a_torressolano_edu_gva_es/_layouts/15/download.aspx?SourceUrl=https://gvaedu-my.sharepoint.com/personal/a_torressolano_edu_gva_es/Documents/04_Benigaslo/10_Plantilles/cc.png)

## Contenidos

1. ¿Qué es un array?
2. Declaración y creación
3. Acceso
4. Recorrido
5. Paso por referencia en métodos
6. Copia de arrays
7. Métodos útiles
8. Arrays multidimensionales

## 1. ¿Qué es un array?

Un **array** es una estructura de datos fundamental en programación que nos permite almacenar múltiples elementos de manera organizada y eficiente. Sus características principales son:

- **Estructura** que almacena una serie de elementos del mismo tipo. Todos los elementos en un array deben ser del mismo tipo de dato (todos números enteros, todos caracteres, todos objetos, etc.), lo que garantiza homogeneidad y facilita el procesamiento consistente de los datos.
- **Acceso por índice** entero (comienza en 0). Cada elemento en el array se identifica por su posición, siendo el primer elemento el índice 0, el segundo el índice 1, y así sucesivamente. Esto permite acceso directo y rápido a cualquier elemento.
- **Tamaño fijo**: el tamaño del array se decide en el momento de su creación y no puede cambiarse posteriormente. Esta característica proporciona seguridad y eficiencia en memoria, pero requiere conocer de antemano cuántos elementos necesitaremos almacenar.
- **Tipos de contenido**: puede contener tipos primitivos (int, double, boolean, etc.) o tipos complejos como objetos. Los objetos los estudiaremos más adelante en el curso.
- **Gestión de errores**: acceder a una posición fuera del rango válido (menor a 0 o mayor o igual a la longitud) lanza una **excepción** `ArrayIndexOutOfBoundsException`, protegiendo la integridad de los datos.

### Tipos de arrays

- **Arrays unidimensionales** (vectores)
- **Arrays multidimensionales** (matrices)
  - En Java son “arrays de arrays”

### Arrays vs listas

- **Arrays**: tamaño fijo
  - Si no se conoce el tamaño estamos obligados a sobredimensionar o redimensionar (crear otro array y copiar)
- **Listas** (List): tamaño variable
  - Alternativa flexible cuando crece dinámicamente (veremos más adelante)

## 2. Declaración y creación

Para utilizar un array en Java, debemos seguir tres pasos fundamentales: **declarar** la variable array, **crear** la instancia con el tamaño deseado, e **inicializar** sus valores.

### Declaración

La **declaración** de un array es el primer paso, donde indicamos el tipo de datos que contendrá y le damos un nombre a la variable. La sintaxis recomendada en Java coloca los corchetes junto al tipo de dato:

```java
int[] numeros;         // recomendado en Java
int numerosC[];        // estilo C (válido pero menos claro)
```

Aunque ambas formas son válidas, la primera forma (`int[]`) es la más utilizada en Java y es considerada más clara y legible. Esta notación indica de manera explícita que estamos trabajando con un tipo array desde el inicio.

Es importante notar que cuando escribimos código como `public static void main(String[] args)`, estamos declarando un parámetro llamado `args` que es un array de cadenas de texto. Este array recibe los argumentos que se pasan al programa cuando se ejecuta desde la línea de comandos.

### Creación (Instanciación)

Después de declarar el array, debemos **crear** una instancia real del mismo. Esto se realiza con la palabra clave `new`, especificando el tipo y el tamaño del array. El tamaño es un número entero positivo que indica cuántos elementos podrá contener el array:

```java
numeros = new int[4];  // crea un array de 4 elementos
```

Podemos combinar la declaración y la creación en una sola línea:

```java
int[] datos = new int[7];  // declara y crea un array de 7 elementos
```

En este momento, el array `datos` existe en memoria con 7 espacios reservados, todos inicializados con sus valores por defecto (0 en el caso de enteros).

### Inicialización manual

Una vez creado el array, podemos asignar valores específicos a cada posición utilizando su índice. Esto se realiza mediante asignaciones individuales:

```java
datos[0] = 10;
datos[1] = -3;
datos[2] = 7;
datos[3] = 0;
datos[4] = 42;
datos[5] = 5;
datos[6] = 9;
```

Este enfoque es útil cuando los valores no siguen un patrón regular y deben asignarse individualmente.

### Inicialización mediante literales

Si conocemos todos los valores del array en el momento de la declaración, podemos utilizar una sintaxis más compacta y elegante con llaves `{}`. Esta forma declara, crea e inicializa el array en una sola línea:

```java
int[] v = {2, -4, 15, -25};
char[] letras = {'a','b','c'};
String[] nombres = {"Ana","Luis","Eva"};
```

El compilador determina automáticamente el tamaño del array contando los elementos dentro de las llaves. Esta es la forma más práctica cuando tenemos valores predefinidos.

### Valores por defecto

Si creamos un array sin inicializar explícitamente sus elementos, Java asigna automáticamente valores por defecto a cada posición. Los valores dependen del tipo de dato:

- **Tipos numéricos** (int, double, float, long, etc.) → `0`
- **Tipo booleano** → `false`
- **Tipos objeto** (como String) → `null` (ausencia de referencia)

Este comportamiento garantiza que nunca tendremos variables sin inicializar, evitando errores potenciales.

## 3. Acceso

Una vez que hemos creado un array, podemos acceder a sus elementos mediante su índice. El acceso a arrays en Java se realiza de tres formas principales: lectura de elementos, escritura de elementos y obtención de la longitud del array.

### Lectura de elementos

Para leer un elemento del array, utilizamos el nombre del array seguido del índice entre corchetes. El valor recuperado puede ser asignado a una variable o utilizado directamente:

```java
int[] v = {10, 20, 30, 40, 50};

int x = v[2];                        // x = 30
System.out.println(v[3]);            // Salida: 40
System.out.println(v[0] + v[1]);     // Salida: 30 (10 + 20)
```

La lectura no modifica el array, es una operación segura que simplemente obtiene el valor almacenado en una posición específica.

### Escritura de elementos

Para modificar o asignar un valor a una posición específica del array, utilizamos el operador de asignación `=`:

```java
int[] v = {10, 20, 30, 40, 50};

v[0] = 99;        // cambia el primer elemento: v = [99, 20, 30, 40, 50]
v[2] = v[2] + 5;  // modifica el tercer elemento: v = [99, 20, 35, 40, 50]
v[4]++;            // incrementa el último elemento: v = [99, 20, 35, 40, 51]
```

La escritura modifica directamente el contenido del array en la posición especificada. Es importante recordar que si intentamos acceder a un índice fuera del rango válido (menor a 0 o mayor o igual a la longitud), el programa lanzará una excepción `ArrayIndexOutOfBoundsException`.

### Propiedad length

Para obtener el número total de elementos en un array, utilizamos la propiedad `length`. Aunque parecida a un método, `length` es una **propiedad** del array, por lo que **no lleva paréntesis**:

```java
int[] v = {10, 20, 30, 40, 50};

int n = v.length;  // n = 5
System.out.println(v.length);  // Salida: 5
```

La propiedad `length` es especialmente útil para:
- **Recorrer arrays dinámicamente** sin necesidad de saber el tamaño exacto
- **Validar índices** antes de acceder a un elemento
- **Iterar correctamente** sobre todos los elementos del array

```java
// Ejemplo: acceso seguro a un elemento
int[] v = {10, 20, 30};
int indice = 5;

// Verificar que el índice es válido antes de acceder
if (indice >= 0 && indice < v.length) {
  System.out.println(v[indice]);
} else {
  System.out.println("Índice fuera de rango");  // Esta línea se ejecutará
}
```

## 4. Recorrido

Una vez que tenemos un array, una de las operaciones más frecuentes es **recorrerlo** para acceder a todos sus elementos de manera sistemática. Java proporciona dos formas principales de hacerlo: el bucle **for** clásico y el bucle **for-each**.

### **for** clásico

El bucle **for** clásico utiliza un contador que comienza en 0 y avanza hasta alcanzar la longitud del array. Esta forma proporciona **control total sobre los índices**, lo que la hace especialmente útil cuando necesitamos conocer la posición de cada elemento.

```java
int[] datos = {1, 2, 3, 4};

for (int i = 0; i < datos.length; i++) {
  System.out.print(datos[i] + " ");
}
// Salida: 1 2 3 4
```

**Ventajas del for clásico:**
- **Control sobre el índice**: podemos usar `i` para saber exactamente en qué posición estamos
- **Flexibilidad**: podemos modificar el contador de formas complejas (saltar elementos, recorrer en orden inverso, etc.)
- **Acceso bidireccional**: podemos recorrer de adelante hacia atrás si es necesario

**Ejemplo: recorrer en orden inverso**
```java
int[] datos = {10, 20, 30, 40};

for (int i = datos.length - 1; i >= 0; i--) {
  System.out.print(datos[i] + " ");
}
// Salida: 40 30 20 10
```

**Ejemplo: recorrer saltando posiciones**
```java
int[] datos = {1, 2, 3, 4, 5, 6};

for (int i = 0; i < datos.length; i += 2) {  // salta de 2 en 2
  System.out.print(datos[i] + " ");
}
// Salida: 1 3 5
```

### **for-each**

El bucle **for-each** (también conocido como bucle mejorado o "enhanced for loop") proporciona una forma más simple y limpia de recorrer todos los elementos de un array cuando **no necesitamos el índice**. La sintaxis es más legible y menos propensa a errores.

```java
int[] datos = {1, 2, 3, 4};

for (int d : datos) {
  System.out.print(d + " ");
}
// Salida: 1 2 3 4
```

En esta sintaxis:
- `int d` es la variable que en cada iteración recibe el valor del elemento actual
- `datos` es el array que se recorre
- El símbolo `:` se lee como "en" o "dentro de"

**Ventajas del for-each:**
- **Sintaxis más clara**: es más legible y menos código
- **Menos errores**: no hay riesgo de errores de índice
- **Más simple**: ideal cuando solo necesitamos el valor, no la posición

**Limitaciones del for-each:**
- No proporciona acceso directo al índice
- No permite modificar el contador o saltar elementos
- No es posible recorrer en orden inverso

### Ejemplo comparativo: cálculo del máximo de un array

Para ilustrar las diferencias entre ambas formas, veamos cómo implementar el cálculo del elemento máximo de un array usando ambos métodos.

**Usando for clásico:**
```java
int[] v = {15, 3, 42, 7, 28, 5};
int max1 = Integer.MIN_VALUE; // valor mínimo posible de un int

for (int i = 0; i < v.length; i++) {
  if (v[i] > max1) {
    max1 = v[i];
  }
}

System.out.println("Máximo: " + max1); // Salida: Máximo: 42
```

**Usando for-each:**
```java
int[] v = {15, 3, 42, 7, 28, 5};
int max2 = Integer.MIN_VALUE; // valor mínimo posible de un int

for (int n : v) {
  if (n > max2) {
    max2 = n;
  }
}

System.out.println("Máximo: " + max2); // Salida: Máximo: 42
```

En este caso, ambas formas producen el mismo resultado, pero el **for-each** es más limpio y directo. Sin embargo, si necesitáramos imprimir también la **posición** del máximo, necesitaríamos el **for** clásico:

**Encontrando el máximo y su posición:**
```java
int[] v = {15, 3, 42, 7, 28, 5};
int max = Integer.MIN_VALUE;
int posicionMax = -1;

for (int i = 0; i < v.length; i++) {
  if (v[i] > max) {
    max = v[i];
    posicionMax = i;
  }
}

System.out.println("Máximo: " + max + " en la posición " + posicionMax); 
// Salida: Máximo: 42 en la posición 2
```

### Elección entre for clásico y for-each

- **Usa for clásico** cuando necesites: el índice, recorrer en orden especial, o acceso flexible al contador
- **Usa for-each** cuando solo necesites: acceder a los valores y la sintaxis sea más legible

## 5. Paso por referencia en métodos

En Java, cuando pasamos un array a un método, no se copia el contenido del array, sino que se pasa una **referencia** al mismo objeto en memoria. Esta característica es fundamental para entender cómo los métodos pueden modificar arrays de manera permanente.

### Concepto de referencia

Una **referencia** es como una dirección o puntero que apunta al array en memoria. Cuando pasamos un array a un método, ambos (la variable original y el parámetro del método) apuntan al **mismo array** en memoria. Por lo tanto, cualquier modificación realizada dentro del método afectará al array original.

```java
// Implementación de un método que modifica un array
void multiplicaPrimeroPor10(int[] x) {
  x[0] *= 10;  // modifica el primer elemento
}

// Uso del método
int[] a = {1, 2, 3};
System.out.println(Arrays.toString(a));  // Salida: [1, 2, 3]

multiplicaPrimeroPor10(a);  // se pasa una referencia a 'a'

System.out.println(Arrays.toString(a));  // Salida: [10, 2, 3]
```

En este ejemplo, aunque `x` es el parámetro del método y `a` es la variable original, ambos **apuntan al mismo array** en memoria. Cuando hacemos `x[0] *= 10`, estamos modificando directamente el primer elemento del array original `a`.

### Modificación del contenido vs. cambio de referencia

Es importante destacar que aunque podemos modificar el **contenido** del array dentro de un método, **no podemos cambiar la referencia original** fuera del método.

**Ejemplo: modificación del contenido (sí funciona)**
```java
void modificaContenido(int[] arr) {
  arr[0] = 100;  // modifica el contenido del array original
}

int[] original = {1, 2, 3};
modificaContenido(original);
System.out.println(Arrays.toString(original));  // [100, 2, 3]
```

**Ejemplo: cambio de referencia (no funciona)**
```java
void cambiaReferencia(int[] arr) {
  arr = new int[5];  // crea un nuevo array local, no afecta a 'original'
  arr[0] = 999;
}

int[] original = {1, 2, 3};
cambiaReferencia(original);
System.out.println(Arrays.toString(original));  // [1, 2, 3] - no cambió
```

En el segundo ejemplo, aunque creamos un nuevo array dentro del método, la variable `original` sigue apuntando al array original. El nuevo array creado en el método se descarta al terminar la función.

### Ventajas y consideraciones

**Ventajas:**
- **Eficiencia en memoria**: no es necesario copiar el array completo para pasarlo a un método
- **Modificación directa**: podemos actualizar arrays sin necesidad de que el método devuelva un valor
- **Parámetro variable**: el método puede procesar arrays de cualquier tamaño

**Consideraciones importantes:**
- **Efectos secundarios**: los cambios dentro del método afectan al array original, lo que puede ser fuente de errores si no se tiene cuidado
- **Documenta el comportamiento**: es recomendable documentar en los comentarios si un método modifica sus parámetros array
- **Cuidado con la mutabilidad**: si el método debe procesar un array sin modificarlo, considera trabajar con una copia

### Ejemplo práctico: método que suma todos los elementos

```java
int sumaArray(int[] numeros) {
  int suma = 0;
  for (int n : numeros) {
    suma += n;
  }
  return suma;  // devuelve un valor, no modifica el array
}

int[] datos = {10, 20, 30, 40};
int total = sumaArray(datos);
System.out.println(total);  // Salida: 100
System.out.println(Arrays.toString(datos));  // Salida: [10, 20, 30, 40]
```

### Ejemplo práctico: método que modifica un array

```java
void doblaValores(int[] numeros) {
  for (int i = 0; i < numeros.length; i++) {
    numeros[i] *= 2;  // modifica cada elemento del array original
  }
}

int[] datos = {5, 10, 15, 20};
System.out.println(Arrays.toString(datos));  // [5, 10, 15, 20]

doblaValores(datos);

System.out.println(Arrays.toString(datos));  // [10, 20, 30, 40]
```

## 6. Copia de arrays

Cuando trabajamos con arrays en Java, uno de los aspectos más importantes es entender las diferentes formas de copiar arrays. El comportamiento varía significativamente según la técnica que utilicemos, afectando directamente a cómo se comparten o se aíslan los datos.

### Asignación simple: copia de referencia

Cuando asignamos una variable array a otra usando el operador `=`, **no se copia el contenido** del array, sino que se copia la **referencia**. Esto significa que ambas variables apuntan al **mismo array** en memoria.

```java
int[] a = {1, 2, 3};
int[] b = a;      // b y a apuntan al mismo array

System.out.println(Arrays.toString(a));  // [1, 2, 3]
System.out.println(Arrays.toString(b));  // [1, 2, 3]
```

Si modificamos uno de los arrays, el cambio afecta a ambos:

```java
int[] a = {1, 2, 3};
int[] b = a;      // b y a apuntan al mismo array

a[0] = 10;        // modifica el array original

System.out.println(Arrays.toString(a));  // [10, 2, 3]
System.out.println(Arrays.toString(b));  // [10, 2, 3] - también cambió
```

Visualmente, la memoria se distribuye de la siguiente manera:

```
Asignación simple (copia de referencia):

    a ──┐
        └──> [ 1, 2, 3 ]
    b ──┘
    
Después de a[0] = 10:

    a ──┐
        └──> [ 10, 2, 3 ]
    b ──┘
```

Esta característica es útil cuando queremos que dos referencias apunten al mismo array, pero puede ser peligrosa si olvidamos que comparten el mismo contenido.

### Clonado: copia mediante clone()

La forma más simple de crear una **copia independiente** de un array es usar el método `clone()`. Este método devuelve un nuevo array con los mismos valores que el original, pero completamente separado en memoria.

```java
int[] a = {1, 2, 3};
int[] b = a.clone();  // crea una copia independiente

System.out.println(Arrays.toString(a));  // [1, 2, 3]
System.out.println(Arrays.toString(b));  // [1, 2, 3]
```

Ahora, modificar uno de los arrays **no afecta al otro**:

```java
int[] a = {1, 2, 3};
int[] b = a.clone();  // copia independiente

a[0] = 10;            // modifica solo 'a'

System.out.println(Arrays.toString(a));  // [10, 2, 3]
System.out.println(Arrays.toString(b));  // [1, 2, 3] - no cambió
```

Visualmente, después del clonado tenemos dos arrays separados en memoria:

```
Clonado (copia independiente):

    a ──> [ 10, 2, 3 ]

    b ──> [ 1, 2, 3 ]
```

**Ventajas de clone():**
- Sintaxis muy simple y clara
- Crea una copia completa e independiente
- Funciona con arrays de cualquier tipo

**Desventaja:**
- Solo crea una **copia superficial** (shallow copy). Para arrays de objetos, esto significa que ambos arrays comparten referencias a los mismos objetos (lo veremos más adelante cuando estudiemos objetos).

### Copia manual: iteración elemento a elemento

Una alternativa más explícita es copiar los elementos manualmente usando un bucle. Esta técnica nos da **control total** sobre el proceso de copia.

```java
int[] a = {1, 2, 3};
int[] b = new int[a.length];  // crear un nuevo array del mismo tamaño

// Copiar cada elemento
for (int i = 0; i < a.length; i++) {
  b[i] = a[i];
}

System.out.println(Arrays.toString(a));  // [1, 2, 3]
System.out.println(Arrays.toString(b));  // [1, 2, 3]
```

Modificar uno no afecta al otro:

```java
a[0] = 10;

System.out.println(Arrays.toString(a));  // [10, 2, 3]
System.out.println(Arrays.toString(b));  // [1, 2, 3] - sigue igual
```

**Ventajas de la copia manual:**
- **Máximo control**: podemos filtrar, transformar o seleccionar qué elementos copiar
- **Claridad explícita**: el código deja muy claro qué está pasando
- **Flexibilidad**: podemos cambiar el tamaño del nuevo array, copiar solo una parte, etc.

**Ejemplo: copiar solo los primeros 5 elementos**
```java
int[] a = {1, 2, 3, 4, 5, 6, 7, 8};
int[] b = new int[5];

for (int i = 0; i < 5 && i < a.length; i++) {
  b[i] = a[i];
}

System.out.println(Arrays.toString(b));  // [1, 2, 3, 4, 5]
```

### Copia usando Arrays.copyOf()

Java proporciona el método utilitario `Arrays.copyOf()` que combina la conveniencia de `clone()` con la flexibilidad de especificar el nuevo tamaño.

```java
int[] a = {1, 2, 3};
int[] b = Arrays.copyOf(a, a.length);  // copia exacta

System.out.println(Arrays.toString(b));  // [1, 2, 3]
```

Si especificamos un tamaño **mayor** que el original, los elementos adicionales se rellenan con el valor por defecto (0 para números, null para objetos):

```java
int[] a = {1, 2, 3};
int[] b = Arrays.copyOf(a, 5);  // nuevo tamaño de 5

System.out.println(Arrays.toString(b));  // [1, 2, 3, 0, 0]
```

Si especificamos un tamaño **menor**, solo se copian los primeros elementos:

```java
int[] a = {1, 2, 3, 4, 5};
int[] b = Arrays.copyOf(a, 3);  // nuevo tamaño de 3

System.out.println(Arrays.toString(b));  // [1, 2, 3]
```

**Ventajas de Arrays.copyOf():**
- Combinación de simplicidad y flexibilidad
- Permite cambiar el tamaño en una sola operación
- Código más conciso que la iteración manual

### Comparación de métodos

| Método | Sintaxis | Copia independiente | Tamaño variable | Complejidad |
|--------|----------|---------------------|-----------------|------------|
| Asignación | `b = a` | ❌ No | N/A | Muy simple |
| `clone()` | `b = a.clone()` | ✅ Sí | ❌ No | Simple |
| Bucle manual | `for...` | ✅ Sí | ✅ Sí | Media |
| `Arrays.copyOf()` | `Arrays.copyOf(a, size)` | ✅ Sí | ✅ Sí | Simple |

### Ejemplo práctico: procesamiento de datos sin modificar original

```java
// Array original con datos importantes
int[] original = {10, 20, 30, 40, 50};

// Crear una copia para trabajar sin afectar el original
int[] copia = original.clone();

// Modificar la copia
for (int i = 0; i < copia.length; i++) {
  copia[i] *= 2;
}

// Verificar que el original no cambió
System.out.println("Original: " + Arrays.toString(original));  // [10, 20, 30, 40, 50]
System.out.println("Copia:    " + Arrays.toString(copia));     // [20, 40, 60, 80, 100]
```

## 7. Métodos útiles

Java proporciona un conjunto completo de métodos utilitarios para trabajar con arrays. La mayoría de estos métodos se encuentran en la clase `Arrays` del paquete `java.util`, que debe importarse al inicio del programa.

```java
import java.util.Arrays;
```

### Propiedad length

La propiedad `length` devuelve el número total de elementos en un array. Aunque parece un método, **no lleva paréntesis** porque es una propiedad del objeto array.

```java
int[] a = {1, 2, 3, 4};
System.out.println(a.length); // Salida: 4
```

La propiedad `length` es especialmente útil en bucles:

```java
int[] numeros = {10, 20, 30, 40};

for (int i = 0; i < numeros.length; i++) {
  System.out.println("Elemento " + i + ": " + numeros[i]);
}
```

### Arrays.toString()

Convierte el contenido de un array en una representación de cadena legible, ideal para depuración e impresión de resultados.

```java
int[] a = {1, 2, 3, 4};
System.out.println(Arrays.toString(a)); // Salida: [1, 2, 3, 4]
```

**Ventajas:**
- Mucho más legible que imprimir el array directamente
- Funciona con cualquier tipo de array
- Produce automáticamente el formato con corchetes y comas

**Comparación:**
```java
int[] a = {1, 2, 3};

System.out.println(a);                    // Salida: [I@1234567 (referencia incomprensible)
System.out.println(Arrays.toString(a));   // Salida: [1, 2, 3] (claro y legible)
```

### Arrays.sort()

Ordena los elementos del array en orden ascendente. **Modifica el array original** directamente.

```java
int[] a = {4, 2, 3, 1};
Arrays.sort(a);
System.out.println(Arrays.toString(a)); // Salida: [1, 2, 3, 4]
```

Funciona con diferentes tipos de datos:

```java
double[] decimales = {3.5, 1.2, 4.8, 2.1};
Arrays.sort(decimales);
System.out.println(Arrays.toString(decimales)); // [1.2, 2.1, 3.5, 4.8]

String[] nombres = {"Eva", "Ana", "Luis", "Carlos"};
Arrays.sort(nombres);
System.out.println(Arrays.toString(nombres)); // [Ana, Carlos, Eva, Luis] (orden alfabético)
```

**Importante:** `Arrays.sort()` modifica el array original. Si necesitas conservar el original, crea una copia primero:

```java
int[] original = {4, 2, 3, 1};
int[] copia = original.clone();
Arrays.sort(copia);

System.out.println("Original: " + Arrays.toString(original)); // [4, 2, 3, 1]
System.out.println("Copia ordenada: " + Arrays.toString(copia)); // [1, 2, 3, 4]
```

### Arrays.binarySearch()

Realiza una **búsqueda binaria** en un array para encontrar un elemento específico. **El array debe estar ordenado previamente** para que funcione correctamente.

Devuelve:
- El **índice** del elemento si se encuentra
- Un número negativo si no se encuentra (específicamente: `-(punto_de_inserción) - 1`)

```java
int[] a = {1, 2, 3, 4, 5};
int index = Arrays.binarySearch(a, 3);
System.out.println(index); // Salida: 2 (el valor 3 está en el índice 2)
```

**Si el elemento no existe:**
```java
int[] a = {1, 2, 3, 4, 5};
int index = Arrays.binarySearch(a, 7);
System.out.println(index); // Salida: -6 (valor negativo indica que no existe)
```

**Ejemplo completo con validación:**
```java
int[] numeros = {5, 2, 8, 1, 9, 3};
Arrays.sort(numeros); // IMPORTANTE: debe estar ordenado

int valor = 8;
int posicion = Arrays.binarySearch(numeros, valor);

if (posicion >= 0) {
  System.out.println("Encontrado en índice: " + posicion);
} else {
  System.out.println("No encontrado");
}
```

### Arrays.equals()

Compara dos arrays para verificar si tienen el **mismo contenido** y la **misma longitud**. Devuelve `true` si son idénticos, `false` en caso contrario.

```java
int[] a = {1, 2, 3};
int[] b = {1, 2, 3};
System.out.println(Arrays.equals(a, b)); // Salida: true

int[] c = {1, 2, 4};
System.out.println(Arrays.equals(a, c)); // Salida: false

int[] d = {1, 2};
System.out.println(Arrays.equals(a, d)); // Salida: false (longitudes diferentes)
```

**No uses `==` para comparar arrays:**
```java
int[] a = {1, 2, 3};
int[] b = {1, 2, 3};

System.out.println(a == b);               // false (compara referencias, no contenido)
System.out.println(Arrays.equals(a, b));  // true (compara el contenido)
```

### Arrays.fill()

Rellena **todos los elementos** del array con un valor especificado. Modifica el array original.

```java
int[] a = new int[5];
Arrays.fill(a, 10);
System.out.println(Arrays.toString(a)); // Salida: [10, 10, 10, 10, 10]
```

También puede rellenar un rango específico del array:

```java
int[] a = {1, 2, 3, 4, 5};
Arrays.fill(a, 1, 4, 0); // rellena desde índice 1 hasta 3 (el 4 es exclusivo)
System.out.println(Arrays.toString(a)); // Salida: [1, 0, 0, 0, 5]
```

**Casos de uso:**
- Inicializar arrays dinámicamente con valores predeterminados
- Resetear arrays a un estado conocido

### String.split()

Aunque `split()` pertenece a la clase `String` (no a `Arrays`), está estrechamente relacionada con arrays porque divide una cadena en un array de subcadenas usando un **delimitador** (separador).

Sintaxis: `String[] resultado = cadena.split(delimitador);`

```java
String texto = "Ana,Luis,Eva,Pedro";
String[] nombres = texto.split(",");
System.out.println(Arrays.toString(nombres)); 
// Salida: [Ana, Luis, Eva, Pedro]
```

**Ejemplo con espacios como delimitador:**
```java
String frase = "Java es un lenguaje potente";
String[] palabras = frase.split(" ");

for (String palabra : palabras) {
  System.out.println(palabra);
}
// Salida:
// Java
// es
// un
// lenguaje
// potente
```

**Ejemplo con delimitador más complejo:**
```java
String datos = "10:20:30:40:50";
String[] valores = datos.split(":");
System.out.println(Arrays.toString(valores)); // [10, 20, 30, 40, 50]
```

**Limitación en el número de divisiones:**
```java
String texto = "A,B,C,D,E";
String[] resultado = texto.split(",", 3); // máximo 3 elementos
System.out.println(Arrays.toString(resultado)); // [A, B, C,D,E]
```

### Arrays.copyOf() (retirado de esta sección)

Este método ya fue analizado en detalle en la sección 6 (Copia de arrays). Aquí recordamos su sintaxis:

```java
int[] original = {1, 2, 3};
int[] copia = Arrays.copyOf(original, 5); // copia con nuevo tamaño
System.out.println(Arrays.toString(copia)); // [1, 2, 3, 0, 0]
```

### Resumen de métodos útiles

| Método | Propósito | Modifica original | Ejemplo |
|--------|-----------|------------------|---------|
| `length` | Obtener tamaño | No | `arr.length` |
| `Arrays.toString()` | Convertir a String | No | `Arrays.toString(arr)` |
| `Arrays.sort()` | Ordenar | **Sí** | `Arrays.sort(arr)` |
| `Arrays.binarySearch()` | Buscar (array ordenado) | No | `Arrays.binarySearch(arr, 5)` |
| `Arrays.equals()` | Comparar contenido | No | `Arrays.equals(a, b)` |
| `Arrays.fill()` | Rellenar con valor | **Sí** | `Arrays.fill(arr, 0)` |
| `String.split()` | Dividir cadena | N/A | `texto.split(",")` |

## 8. Arrays multidimensionales

Hasta ahora hemos trabajado con arrays unidimensionales (vectores), que almacenan una serie lineal de elementos. Sin embargo, en muchas aplicaciones necesitamos organizar datos en estructuras bidimensionales (tablas o matrices) o incluso de más dimensiones. Java nos permite crear estas estructuras mediante arrays de arrays.

### Concepto básico: arrays 2D

Un **array 2D** (bidimensional) se puede visualizar como una tabla con **filas** y **columnas**. En Java, se implementa como un **array de arrays**: cada fila es en sí misma un array, y el array principal contiene todas las filas.

```java
int[][] m = new int[3][4]; // 3 filas, 4 columnas
```

Para acceder a un elemento específico, utilizamos dos índices: el primero para la fila y el segundo para la columna:

```java
m[2][1] = 24; // asigna el valor 24 a la fila 2, columna 1
```

### Visualización de arrays 2D

Para entender mejor la estructura, veamos cómo se organiza la matriz anterior:

| Fila | Columna 0 | Columna 1 | Columna 2 | Columna 3 |
|------|-----------|-----------|-----------|-----------|
| 0    | 0         | 0         | 0         | 0         |
| 1    | 0         | 0         | 0         | 0         |
| 2    | 0         | 24        | 0         | 0         |

Cada celda `[fila][columna]` contiene un valor. El índice de fila va de 0 a 2, y el índice de columna va de 0 a 3.

### Declaración y creación

Hay varias formas de declarar y crear arrays 2D:

**Forma 1: Declaración y creación separadas**
```java
int[][] matriz;              // declaración
matriz = new int[3][4];      // creación: 3 filas, 4 columnas
```

**Forma 2: Declaración y creación en una línea**
```java
int[][] matriz = new int[3][4];
```

**Forma 3: Declaración y inicialización con valores**
```java
int[][] matriz = {
  {1, 2, 3, 4},
  {5, 6, 7, 8},
  {9, 10, 11, 12}
};
```

### Acceso a elementos

Para leer o escribir un elemento, usamos dos índices:

```java
int[][] m = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};

// Lectura
int valor = m[1][2];  // obtiene el valor 6 (fila 1, columna 2)

// Escritura
m[0][0] = 100;  // cambia el primer elemento a 100

// Operaciones
m[2][1] += 10;  // suma 10 al elemento en fila 2, columna 1
```

### Propiedades length

Como Java implementa arrays 2D como arrays de arrays, cada fila es en sí misma un array con su propia propiedad `length`:

```java
int[][] m = new int[3][4]; // 3 filas, 4 columnas

m.length;      // número de filas (3)
m[0].length;   // número de columnas en la fila 0 (4)
m[1].length;   // número de columnas en la fila 1 (4)
m[2].length;   // número de columnas en la fila 2 (4)
```

Esta característica es fundamental para iterar correctamente sobre la matriz:

```java
int[][] m = {
  {1, 2, 3},
  {4, 5, 6}
};

System.out.println(m.length);      // 2 (filas)
System.out.println(m[0].length);   // 3 (columnas)
```

### Matrices irregulares

Una característica única de Java es que permite crear matrices **irregulares** (jagged arrays), donde cada fila puede tener un número diferente de columnas. Esto es posible porque cada fila es un array independiente.

**Creación de matriz irregular:**
```java
int[][] b = new int[3][]; // 3 filas, pero sin especificar columnas

b[0] = new int[2];  // primera fila con 2 columnas
b[1] = new int[5];  // segunda fila con 5 columnas
b[2] = new int[3];  // tercera fila con 3 columnas
```

Visualización:

| Fila | Col 0 | Col 1 | Col 2 | Col 3 | Col 4 | Elementos |
|------|-------|-------|-------|-------|-------|-----------|
| 0    | 0     | 0     | —     | —     | —     | 2         |
| 1    | 0     | 0     | 0     | 0     | 0     | 5         |
| 2    | 0     | 0     | 0     | —     | —     | 3         |

**Inicialización de matriz irregular:**
```java
int[][] c = {
  {10, 20},
  {30, 40, 50, 60},
  {70}
};

System.out.println(c[0].length);  // 2
System.out.println(c[1].length);  // 4
System.out.println(c[2].length);  // 1
```

Las matrices irregulares son útiles en situaciones donde cada fila tiene un número variable de elementos, como representar datos de diferente longitud.

### Recorrido con for clásico

Para recorrer una matriz 2D usando el bucle **for** clásico, utilizamos dos bucles anidados: uno para las filas y otro para las columnas.

```java
int[][] m = {
  {1, 2, 3, 4, 5},
  {6, 7, 8, 9, 10}
};

// Bucle externo: itera sobre las filas
for (int i = 0; i < m.length; i++) {
  // Bucle interno: itera sobre las columnas de la fila i
  for (int j = 0; j < m[i].length; j++) {
    System.out.print(m[i][j] + "\t");  // \t para tabulación
  }
  System.out.println();  // salto de línea después de cada fila
}
```

**Salida:**
```
1   2   3   4   5
6   7   8   9   10
```

### Recorrido con for-each

El bucle **for-each** también funciona con arrays 2D, pero de forma un poco diferente. Podemos iterar sobre las filas (arrays) y luego sobre los elementos de cada fila:

```java
int[][] m = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9}
};

// for-each externo: obtiene cada fila como un array
for (int[] fila : m) {
  // for-each interno: obtiene cada elemento de la fila
  for (int dato : fila) {
    System.out.print(dato + " ");
  }
  System.out.println();
}
```

**Salida:**
```
1 2 3
4 5 6
7 8 9
```

**Comparación:** El **for-each** es más legible cuando no necesitas el índice, mientras que el **for** clásico es mejor si necesitas acceso a las posiciones.

### Ejemplo práctico: Matriz identidad

Una **matriz identidad** es una matriz cuadrada donde los elementos de la diagonal principal son 1 y el resto son 0. Por ejemplo, una matriz identidad 4×4:

```
1  0  0  0
0  1  0  0
0  0  1  0
0  0  0  1
```

**Implementación:**
```java
int[][] I = new int[4][4];

// Inicializar matriz identidad
for (int i = 0; i < I.length; i++) {
  for (int j = 0; j < I[i].length; j++) {
    // Asignar 1 si estamos en la diagonal (i == j), 0 en otro caso
    I[i][j] = (i == j) ? 1 : 0;
  }
}

// Imprimir matriz identidad
System.out.println("Matriz identidad:");
for (int i = 0; i < I.length; i++) {
  for (int j = 0; j < I[i].length; j++) {
    System.out.print(I[i][j] + "\t");
  }
  System.out.println();
}
```

**Salida:**
```
Matriz identidad:
1   0   0   0
0   1   0   0
0   0   1   0
0   0   0   1
```

### Ejemplo práctico: Suma de matriz

```java
int[][] m1 = {
  {1, 2},
  {3, 4}
};

int[][] m2 = {
  {5, 6},
  {7, 8}
};

// Crear matriz resultado
int[][] suma = new int[2][2];

// Sumar elemento a elemento
for (int i = 0; i < m1.length; i++) {
  for (int j = 0; j < m1[i].length; j++) {
    suma[i][j] = m1[i][j] + m2[i][j];
  }
}

// Imprimir resultado
for (int[] fila : suma) {
  for (int elem : fila) {
    System.out.print(elem + " ");
  }
  System.out.println();
}
```

**Salida:**
```
6  8
10 12
```

### Generalización a N dimensiones

Java permite crear arrays de **más de 2 dimensiones**. Un array 3D es un array de arrays 2D, un array 4D es un array de arrays 3D, y así sucesivamente.

```java
// Array 3D: 2 matrices de 3 filas x 4 columnas
int[][][] t = new int[2][3][4];
```

El número total de elementos en un array multidimensional es el **producto de todas las dimensiones**:

```java
// Total de elementos = 2 * 3 * 4 = 24
int[][][] cubo = new int[2][3][4];
```

**Acceso a elementos en 3D:**
```java
int[][][] t = new int[2][3][4];
t[1][2][3] = 100;  // acceso con tres índices
```

**Creación con inicialización:**
```java
int[][][] cubo = {
  {
    {1, 2},
    {3, 4}
  },
  {
    {5, 6},
    {7, 8}
  }
};

System.out.println(cubo[0][0][1]);  // 2
System.out.println(cubo[1][1][0]);  // 7
```

### Resumen de arrays multidimensionales

| Concepto | Descripción |
|----------|-------------|
| **Array 2D** | Tabla de filas y columnas: `int[][] m = new int[3][4]` |
| **Acceso** | Uso de dos índices: `m[fila][columna]` |
| **Longitudes** | `m.length` para filas, `m[i].length` para columnas |
| **Irregular** | Cada fila puede tener diferente longitud |
| **For clásico** | Dos bucles anidados para filas y columnas |
| **For-each** | Más legible cuando no se necesitan índices |
| **N dimensiones** | Arrays de 3D, 4D, etc., siguiendo el mismo principio |

Los arrays multidimensionales son herramientas poderosas para representar estructuras de datos complejas como matrices matemáticas, tableros de juegos, o sistemas de coordenadas.
