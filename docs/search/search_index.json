{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Programaci\u00f3n en Java \u2014 DAM y DAW","text":"<p>P\u00e1gina de inicio de la asignatura de Programaci\u00f3n en Java para los ciclos DAM y DAW. Contenidos y pr\u00e1cticas orientados a desarrollar competencias s\u00f3lidas en programaci\u00f3n orientada a objetos y desarrollo de aplicaciones.</p>"},{"location":"#enlaces-del-curso","title":"Enlaces del curso","text":"<ul> <li>Temario</li> <li>Ejercicios</li> <li>Pr\u00e1cticas</li> <li>Proyecto final</li> <li>Recursos</li> </ul>"},{"location":"#objetivos-de-aprendizaje","title":"Objetivos de aprendizaje","text":"<ul> <li>Comprender la sintaxis y modelo de ejecuci\u00f3n de Java.</li> <li>Aplicar POO: clases, objetos, herencia, interfaces y polimorfismo.</li> <li>Gestionar colecciones, gen\u00e9ricos y flujos de datos.</li> <li>Manejar excepciones y escribir c\u00f3digo robusto y mantenible.</li> <li>Persistir datos con ficheros y JDBC b\u00e1sico.</li> <li>Automatizar con Maven/Gradle y versionar con Git.</li> <li>Escribir pruebas unitarias con JUnit y usar depuraci\u00f3n.</li> </ul>"},{"location":"#contenidos-principales","title":"Contenidos principales","text":"<ul> <li>Fundamentos de Java y tipos de datos.</li> <li>Control de flujo, m\u00e9todos y encapsulaci\u00f3n.</li> <li>POO avanzada, paquetes y modularizaci\u00f3n.</li> <li>Colecciones, gen\u00e9ricos, streams y lambdas.</li> <li>Manejo de excepciones y logging.</li> <li>Ficheros (texto/binario), JSON y serializaci\u00f3n.</li> <li>JDBC b\u00e1sico y acceso a base de datos.</li> <li>Testing con JUnit y dobles de prueba.</li> <li>Herramientas: Maven/Gradle, Git, CI b\u00e1sica.</li> <li>Introducci\u00f3n a aplicaciones de consola; enfoque a backend en DAW y a apps de escritorio/m\u00f3vil en DAM.</li> </ul>"},{"location":"#requisitos-y-entorno","title":"Requisitos y entorno","text":"<ul> <li>JDK 21 LTS o superior.</li> <li>IDE recomendado: IntelliJ IDEA Community (o Eclipse/VS Code con Java).</li> <li>Maven o Gradle, Git.</li> </ul> <p>Verificaci\u00f3n r\u00e1pida: <pre><code>java -version\njavac -version\nmvn -v   # opcional\ngradle -v  # opcional\n</code></pre></p>"},{"location":"#como-empezar","title":"C\u00f3mo empezar","text":"<ol> <li>Instalar JDK 21 LTS: https://adoptium.net</li> <li>Instalar un IDE: https://www.jetbrains.com/idea/ o https://www.eclipse.org/ o https://code.visualstudio.com/ con Extension Pack for Java.</li> <li>Configurar Git: https://git-scm.com</li> <li>Crear proyecto y ejecutar prueba: <pre><code>public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hola, Java DAM/DAW\");\n    }\n}\n</code></pre></li> </ol>"},{"location":"#metodologia-y-evaluacion","title":"Metodolog\u00eda y evaluaci\u00f3n","text":"<ul> <li>Evaluaci\u00f3n continua con actividades semanales y revisiones de c\u00f3digo.</li> <li>Pr\u00e1cticas y ejercicios: 50%</li> <li>Proyecto final: 30%</li> <li>Pruebas te\u00f3rico-pr\u00e1cticas: 20% Criterios: funcionamiento, calidad de c\u00f3digo, pruebas y documentaci\u00f3n. Requisito m\u00ednimo en cada bloque para superar la asignatura.</li> </ul>"},{"location":"#normas-y-buenas-practicas","title":"Normas y buenas pr\u00e1cticas","text":"<ul> <li>Estilo: Google Java Style Guide con Checkstyle/SpotBugs.</li> <li>Control de versiones con ramas y pull requests.</li> <li>Pruebas y cobertura m\u00ednimas en entregas.</li> <li>Documentaci\u00f3n breve en README y comentarios Javadoc cuando proceda.</li> </ul>"},{"location":"#recursos-recomendados","title":"Recursos recomendados","text":"<ul> <li>Documentaci\u00f3n oficial: https://docs.oracle.com/en/java/</li> <li>Especificaci\u00f3n del lenguaje: https://docs.oracle.com/javase/specs/</li> <li>JUnit 5: https://junit.org/junit5/</li> <li>Gu\u00eda de estilo Java: https://google.github.io/styleguide/javaguide.html</li> <li>Tutoriales Java (Oracle): https://docs.oracle.com/javase/tutorial/</li> </ul> <p>Sugerencia: crea las p\u00e1ginas enlazadas (temario.md, ejercicios.md, practicas.md, proyecto.md, recursos.md) para completar la navegaci\u00f3n del sitio.</p>"},{"location":"about/","title":"Contacto","text":"<p>contacto</p> <ul> <li>Profesor: Alejandro Torres Solano</li> <li>email: a.torressolano@edu.gva.es</li> </ul>"},{"location":"U01/U01.1/","title":"Algoritmos I","text":""},{"location":"U01/U01.1/#que-es-un-algoritmo","title":"\u00bfQu\u00e9 es un algoritmo?","text":"<p>Un algoritmo es la forma de expresar la resoluci\u00f3n de un problema en la fase previa a la codificaci\u00f3n.</p> <p>Proceso de desarrollo:</p> <ol> <li>Especificaci\u00f3n del problema</li> <li>Dise\u00f1o del algoritmo</li> <li>Codificaci\u00f3n del programa</li> <li>Pruebas y validaci\u00f3n</li> </ol>"},{"location":"U01/U01.1/#tipos-de-algoritmos","title":"Tipos de algoritmos","text":"<p>Existen diferentes formas de representar algoritmos:</p> <ul> <li>Diagramas de flujo: Representaci\u00f3n gr\u00e1fica del proceso</li> <li>Pseudoc\u00f3digo: Descripci\u00f3n en lenguaje natural estructurado</li> </ul>"},{"location":"U01/U01.1/#diagramas-de-flujo","title":"Diagramas de flujo","text":"<p>Los diagramas de flujo expresan el dise\u00f1o del programa de forma gr\u00e1fica. Permiten representar el problema a diferentes niveles de refinamiento o detalle, desde bloques generales hasta instrucciones espec\u00edficas.</p>"},{"location":"U01/U01.1/#simbolos-basicos","title":"S\u00edmbolos b\u00e1sicos","text":"S\u00edmbolo Descripci\u00f3n Representaci\u00f3n Inicio/Fin Indica el inicio o fin del algoritmo \u00d3valo Proceso Representa una operaci\u00f3n o instrucci\u00f3n Rect\u00e1ngulo Decisi\u00f3n Eval\u00faa una condici\u00f3n (verdadero/falso) Rombo Entrada/Salida Lectura de datos o escritura de resultados Paralelogramo Conector Conecta diferentes partes del diagrama C\u00edrculo Flujo Indica la direcci\u00f3n del flujo de ejecuci\u00f3n Flecha <pre><code>graph LR\n    A([Inicio/Fin])\n    B[Proceso]\n    C{Decisi\u00f3n}\n    D[/Entrada-Salida/]\n    E((Conector))</code></pre>"},{"location":"U01/U01.1/#ejemplo-verificar-si-un-numero-es-positivo","title":"Ejemplo: Verificar si un n\u00famero es positivo","text":"<pre><code>flowchart TD\n    A([Inicio]) --&gt; B[/Leer n\u00famero/]\n    B --&gt; C{\u00bfn\u00famero &gt; 0?}\n    C --&gt;|S\u00ed| D[/Escribir 'Positivo'/]\n    C --&gt;|No| E[/Escribir 'No positivo'/]\n    D --&gt; F([Fin])\n    E --&gt; F</code></pre>"},{"location":"U01/U01.1/#reglas-de-construccion","title":"Reglas de construcci\u00f3n","text":"<ul> <li>Desarrollar siempre de arriba abajo y de izquierda a derecha</li> <li>En s\u00edmbolos de decisi\u00f3n: salida por la derecha cuando se cumple, por la izquierda cuando no</li> <li>Toda l\u00ednea de ejecuci\u00f3n debe tener una salida o soluci\u00f3n</li> <li>Seguir estas convenciones facilita la comprensi\u00f3n universal de los diagramas</li> </ul>"},{"location":"U01/U01.1/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<p>El pseudoc\u00f3digo es la expresi\u00f3n escrita en lenguaje natural de un algoritmo, siguiendo una estructura similar a la de un lenguaje de programaci\u00f3n.</p>"},{"location":"U01/U01.1/#ejemplo-1-calcular-el-area-de-un-triangulo","title":"Ejemplo 1: Calcular el \u00e1rea de un tri\u00e1ngulo","text":"<p>Diagrama de flujo:</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; B[/Leer base/]\n    B --&gt; C[/Leer altura/]\n    C --&gt; D[area = base \u00d7 altura \u00f7 2]\n    D --&gt; E[/Escribir area/]\n    E --&gt; F([Fin])</code></pre> <p>Pseudoc\u00f3digo:</p> <pre><code>Inicio\n    Leer base\n    Leer altura\n    area = base * altura / 2\n    Escribir area\nFin\n</code></pre>"},{"location":"U01/U01.1/#ejemplo-2-bucle-de-conteo","title":"Ejemplo 2: Bucle de conteo","text":"<p>Pseudoc\u00f3digo:</p> <pre><code>Inicio\n    x = 0\n    Mientras x &lt;= 10 hacer\n        Escribir x\n        x = x + 1\n    FinMientras\nFin\n</code></pre> <p>Diagrama de flujo:</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; B[x = 0]\n    B --&gt; C{\u00bfx &lt;= 10?}\n    C --&gt;|S\u00ed| D[/Escribir x/]\n    D --&gt; E[x = x + 1]\n    E --&gt; C\n    C --&gt;|No| F([Fin])</code></pre>"},{"location":"U01/U01.1/#algoritmos-ii","title":"Algoritmos II","text":""},{"location":"U01/U01.1/#estructuras-basicas","title":"Estructuras b\u00e1sicas","text":"<p>Cualquier programa se puede resolver utilizando una o varias de las estructuras b\u00e1sicas:</p> <ul> <li>Secuenciales</li> <li>Alternativas</li> <li>Repetitivas</li> </ul>"},{"location":"U01/U01.1/#estructura-secuencial","title":"Estructura secuencial","text":"<ul> <li>La ejecuci\u00f3n tiene un comienzo y un final</li> <li>Las instrucciones se ejecutan en el mismo orden en el que est\u00e1n escritas</li> <li>Puede haber una o muchas instrucciones desde que se inicia la ejecuci\u00f3n hasta su final</li> </ul>"},{"location":"U01/U01.1/#ejemplo-calculo-del-area-y-longitud-de-una-circunferencia","title":"Ejemplo: C\u00e1lculo del \u00e1rea y longitud de una circunferencia","text":"<pre><code>flowchart TD\n    A([Inicio]) --&gt; B[Declarar constante Pi = 3.1416]\n    B --&gt; C[/Leer radio/]\n    C --&gt; D[area = Pi \u00d7 radio\u00b2]\n    D --&gt; E[longitud = 2 \u00d7 Pi \u00d7 radio]\n    E --&gt; F[/Mostrar area y longitud/]\n    F --&gt; G([Fin])</code></pre>"},{"location":"U01/U01.1/#estructura-alternativa","title":"Estructura alternativa","text":"<p>Permite tomar decisiones seg\u00fan el cumplimiento de condiciones:</p> <ul> <li>Pueden tener una o dos salidas (<code>if...then...else</code>)</li> <li>Pueden tener varias salidas (<code>switch...case</code>)</li> <li>Pueden contener otras estructuras anidadas</li> </ul>"},{"location":"U01/U01.1/#ejemplo-simple-comparar-dos-numeros","title":"Ejemplo simple: Comparar dos n\u00fameros","text":"<pre><code>flowchart TD\n    A([Inicio]) --&gt; B[/Leer A y B/]\n    B --&gt; C{\u00bfA &gt; B?}\n    C --&gt;|S\u00ed| D[/Mostrar A/]\n    C --&gt;|No| E[/Mostrar B/]\n    D --&gt; F([Fin])\n    E --&gt; F</code></pre>"},{"location":"U01/U01.1/#alternativas-anidadas","title":"Alternativas anidadas","text":"<p>Las instrucciones alternativas pueden estar anidadas unas dentro de otras, permitiendo evaluar m\u00faltiples condiciones en secuencia.</p> <p>Anidamiento</p> <p>Una condici\u00f3n puede contener otra condici\u00f3n en su interior, creando niveles de decisi\u00f3n m\u00e1s complejos.</p>"},{"location":"U01/U01.1/#estructura-repetitiva","title":"Estructura repetitiva","text":"<p>Ejecuta un bloque de instrucciones varias veces seg\u00fan una condici\u00f3n.</p>"},{"location":"U01/U01.1/#tipos-de-bucles","title":"Tipos de bucles","text":"Tipo Sintaxis Evaluaci\u00f3n Mientras <code>while</code> Al inicio del bucle Repite...Hasta <code>do...while</code> Al final del bucle <p>Diferencia clave</p> <ul> <li>Condici\u00f3n inicial (<code>while</code>): El bucle puede no ejecutarse nunca</li> <li>Condici\u00f3n final (<code>do...while</code>): El bucle se ejecuta al menos una vez</li> </ul>"},{"location":"U01/U01.1/#ejemplo-1-bucle-con-condicion-final-dowhile","title":"Ejemplo 1: Bucle con condici\u00f3n final (do...while)","text":"<p>Pseudoc\u00f3digo:</p> <pre><code>Inicio\n    x = 10\n    Repite\n        Escribir x\n        x = x + 1\n    Hasta que x &gt; 20\nFin\n</code></pre> <p>Diagrama de flujo:</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; B[x = 10]\n    B --&gt; C[/Mostrar x/]\n    C --&gt; D[x = x + 1]\n    D --&gt; E{\u00bfx &gt; 20?}\n    E --&gt;|No| C\n    E --&gt;|S\u00ed| F([Fin])</code></pre>"},{"location":"U01/U01.1/#ejemplo-2-bucle-con-condicion-inicial-while","title":"Ejemplo 2: Bucle con condici\u00f3n inicial (while)","text":"<p>Pseudoc\u00f3digo:</p> <pre><code>Inicio\n    x = 10\n    Mientras x &lt;= 20\n        Escribir x\n        x = x + 1\n    FinMientras\nFin\n</code></pre> <p>Diagrama de flujo:</p> <pre><code>flowchart TD\n    A([Inicio]) --&gt; B[x = 10]\n    B --&gt; C{\u00bfx &lt;= 20?}\n    C --&gt;|S\u00ed| D[/Mostrar x/]\n    D --&gt; E[x = x + 1]\n    E --&gt; C\n    C --&gt;|No| F([Fin])</code></pre>"},{"location":"U01/U01.1/#resumen-de-estructuras","title":"Resumen de estructuras","text":"Estructura Caracter\u00edstica Uso Secuencial Instrucciones en orden Operaciones lineales Alternativa Decisiones (<code>if</code>, <code>switch</code>) Bifurcaciones Repetitiva Bucles (<code>while</code>, <code>do...while</code>) Iteraciones"},{"location":"U01/U01.2/","title":"Algoritmos II","text":""},{"location":"U01/U01.2/#estructuras-basicas","title":"Estructuras b\u00e1sicas","text":"<p>Cualquier programa se puede resolver utilizando una o varias de las estructuras b\u00e1sicas: - Secuenciales - Alternativas - Repetitivas</p>"},{"location":"U01/U01.2/#secuencial","title":"Secuencial","text":"<p>La ejecuci\u00f3n tiene un comienzo y un final. Las instrucciones se ejecutan en el mismo orden en el que est\u00e1n escritas.</p>"},{"location":"U01/U01.2/#ejemplo-mermaid","title":"Ejemplo (Mermaid)","text":"<pre><code>flowchart TD\n    A[Inicio] --&gt; B[Declarar constante Pi]\n    B --&gt; C[Leer radio]\n    C --&gt; D[Calcular \u00e1rea y longitud]\n    D --&gt; E[Mostrar resultados]\n    E --&gt; F[Fin]</code></pre>"},{"location":"U01/U01.2/#alternativa","title":"Alternativa","text":"<p>Pueden tener una o dos salidas (if...else), varias salidas (switch...case) y pueden contener otras estructuras anidadas.</p>"},{"location":"U01/U01.2/#ejemplo-simple","title":"Ejemplo simple","text":"<pre><code>flowchart TD\n    A[Inicio] --&gt; B[Leer A y B]\n    B --&gt; C{\u00bfA &gt; B?}\n    C --&gt;|S\u00ed| D[Mostrar A]\n    C --&gt;|No| E[Mostrar B]\n    D --&gt; F[Fin]\n    E --&gt; F[Fin]</code></pre>"},{"location":"U01/U01.2/#repetitiva","title":"Repetitiva","text":"<p>Ejecuta instrucciones varias veces seg\u00fan una condici\u00f3n. Tipos: Mientras (while), Repite...Hasta (do...while).</p>"},{"location":"U01/U01.2/#ejemplo-mostrar-numeros-del-10-al-20","title":"Ejemplo: Mostrar n\u00fameros del 10 al 20","text":"<pre><code>flowchart TD\n    A[Inicio] --&gt; B[x = 10]\n    B --&gt; C[Mostrar x]\n    C --&gt; D[Incrementar x]\n    D --&gt; E{\u00bfx &lt;= 20?}\n    E --&gt;|S\u00ed| C\n    E --&gt;|No| F[Fin]</code></pre>"},{"location":"U01/U01.2/#pseudocodigo-del-bucle","title":"Pseudoc\u00f3digo del bucle","text":"<pre><code>Inicio\nx = 10\nRepite\n    Escribir x\n    x = x + 1\nHasta que x &gt; 20\nFin\n</code></pre>"},{"location":"U02/U02.1/","title":"2.1 - M\u00e9todos","text":""},{"location":"U02/U02.1/#metodos","title":"M\u00e9todos","text":""},{"location":"U02/U02.1/#unidad-21","title":"Unidad 2.1","text":""},{"location":"U02/U02.1/#contenidos","title":"Contenidos","text":"<ol> <li>\u00bfQu\u00e9 es un m\u00e9todo?</li> <li>Crear un m\u00e9todo</li> <li>Valor de retorno</li> <li>Llamar a un m\u00e9todo</li> <li>Paso de argumentos</li> <li>M\u00e9todos sobrecargados</li> <li>\u00c1mbito de definici\u00f3n de m\u00e9todos</li> <li>Uso de m\u00e9todos de otras clases</li> </ol>"},{"location":"U02/U02.1/#1-que-es-un-metodo","title":"1. \u00bfQu\u00e9 es un m\u00e9todo?","text":"<ul> <li>Conjunto de instrucciones referenciadas por un identificador  </li> <li>Puede ser llamado desde distintos puntos del programa  </li> <li>Existen dos tipos de m\u00e9todos:</li> <li>Funciones: devuelven un valor</li> <li>Procedimientos: no devuelven un valor</li> </ul>"},{"location":"U02/U02.1/#ejemplos-de-metodos-en-java","title":"Ejemplos de m\u00e9todos en Java","text":"<pre><code>double rx = Math.sqrt(78);\nint i = entrada.nextInt();\nSystem.out.println(\"Hola a todos\");\n</code></pre> <ul> <li>Identificador: <code>sqrt</code>, <code>nextInt</code>, <code>println</code> </li> <li>Par\u00e1metros entre par\u00e9ntesis  </li> <li>Algunos devuelven resultado (<code>sqrt</code> y <code>nextInt</code>), otros no (<code>println</code>)</li> </ul>"},{"location":"U02/U02.1/#2-ventajas-de-definir-metodos","title":"2. Ventajas de definir m\u00e9todos","text":"<ul> <li>Reutilizaci\u00f3n de c\u00f3digo </li> <li>Resoluci\u00f3n de subproblemas</li> <li>Mejora la legibilidad</li> </ul>"},{"location":"U02/U02.1/#3-invocacion-de-metodos","title":"3. Invocaci\u00f3n de m\u00e9todos","text":""},{"location":"U02/U02.1/#llamada-a-metodos","title":"Llamada a m\u00e9todos","text":"<ul> <li>Un m\u00e9todo puede llamar (o invocar) a otro, y se transfiere el control hasta que termina  </li> <li>Un m\u00e9todo se puede llamar a s\u00ed mismo (recursividad)  </li> <li>Como sabemos, en Java, el programa siempre empieza a ejecutarse en el m\u00e9todo <code>main</code>, que podr\u00e1 llamar a otros m\u00e9todos</li> </ul>"},{"location":"U02/U02.1/#diagrama-de-llamada","title":"Diagrama de llamada","text":"<ul> <li>M1 \u27a1\ufe0f M2: M1 llama a M2  </li> <li>Se pueden transferir datos (par\u00e1metros)  </li> <li>M1 \u2b05\ufe0f M2: M2 devuelve el control a M1  </li> <li>Puede devolver un dato de salida</li> </ul>"},{"location":"U02/U02.1/#4-crear-un-metodo","title":"4. Crear un m\u00e9todo","text":""},{"location":"U02/U02.1/#componentes-de-un-metodo","title":"Componentes de un m\u00e9todo","text":"<pre><code>static tipo_devuelto nombre([argumentos]) {\n  // instrucciones\n  return valor;\n}\n</code></pre> <ul> <li><code>tipo_devuelto</code>: tipo de dato del valor que devuelve (<code>void</code> si no devuelve nada)</li> <li><code>argumentos</code>: tipo de dato y nombre de cada par\u00e1metro dentro del m\u00e9todo (opcional)</li> <li><code>return</code>: especifica el valor devuelto (inexistente si <code>void</code>)</li> </ul>"},{"location":"U02/U02.1/#ejemplo","title":"Ejemplo","text":"<ul> <li>M\u00e9todo <code>suma</code> que devuelve la suma de dos enteros</li> </ul> <pre><code>static int suma(int a, int b) {\n  return a + b;\n}\n</code></pre>"},{"location":"U02/U02.1/#5-valor-de-retorno","title":"5. Valor de retorno","text":""},{"location":"U02/U02.1/#ejemplo_1","title":"Ejemplo","text":"<pre><code>static int maximo(int x, int y) {\n  if (x &gt;= y) return x;\n  else return y;\n}\n</code></pre> <ul> <li><code>return</code> especifica el valor devuelto  </li> <li>Devuelve el control al m\u00e9todo invocador</li> </ul>"},{"location":"U02/U02.1/#6-llamar-a-un-metodo","title":"6. Llamar a un m\u00e9todo","text":""},{"location":"U02/U02.1/#ejemplo-de-m1-que-llama-a-m2","title":"Ejemplo de M1 que llama a M2","text":"<ul> <li>Argumentos actuales: contiene los valores con los que M1 invoca a M2 <code>M2(arg1, arg2, ..., argN);</code></li> <li> <p>Argumentos formales: especificados en la cabecera de M2 <code>M2(tipo arg1, tipo arg2, ..., tipo argN)</code></p> </li> <li> <p>Los argumentos actuales deben coincidir en n\u00famero y tipo con los formales</p> </li> </ul>"},{"location":"U02/U02.1/#ejemplo-1","title":"Ejemplo 1","text":"<ul> <li>Implementaci\u00f3n del m\u00e9todo <code>suma</code> <pre><code>static int suma(int a, int b) {\n  return a + b;\n}\n</code></pre></li> <li>Distintas llamadas al m\u00e9todo <code>suma</code> desde <code>main</code> <pre><code>public static void main(String[] args) {\n  int y = suma(5, 3); // y vale 8\n  int z = suma(7, 10); // z vale 17\n}\n</code></pre></li> </ul>"},{"location":"U02/U02.1/#ejemplo-2","title":"Ejemplo 2","text":"<ul> <li>Implementaci\u00f3n del m\u00e9todo <code>maximo</code> <pre><code>static int maximo(int x, int y) {\n  if (x &gt;= y) return x;\n  else return y;\n}\n</code></pre></li> </ul>"},{"location":"U02/U02.1/#ejemplo-2_1","title":"Ejemplo 2","text":"<ul> <li>Obtenci\u00f3n del m\u00e1ximo de cuatro n\u00fameros <pre><code>public static void main(String[] args) {\n  int a = 5, b = 12, c = 8, d = 3;\n  int max1 = maximo(a, b); // max1 vale 12\n  int max2 = maximo(c, d); // max2 vale 8\n  int max = maximo(max1, max2); // max vale 12\n}\n</code></pre></li> </ul>"},{"location":"U02/U02.1/#ejemplo-2_2","title":"Ejemplo 2","text":"<ul> <li>Otra manera de obtener el m\u00e1ximo de los cuatro n\u00fameros <pre><code>public static void main(String[] args) {\n  int a = 5, b = 12, c = 8, d = 3;\n  int max = maximo(maximo(a, b), maximo(c, d));\n}\n</code></pre></li> </ul>"},{"location":"U02/U02.1/#cabecera-vs-llamada","title":"Cabecera vs llamada","text":"Cabecera (args. formales) Llamada (args. actuales) <code>int suma(int a, int b)</code> <code>suma(2, 4)</code> <code>int maximo(int x, int y)</code> <code>maximo(7, 9)</code> <code>void imprime(int a, float b, char c)</code> <code>imprime(numero, 3.14, 'x')</code>"},{"location":"U02/U02.1/#7-paso-de-argumentos","title":"7. Paso de argumentos","text":""},{"location":"U02/U02.1/#tipos-de-paso","title":"Tipos de paso","text":"<ul> <li>Por valor: El m\u00e9todo no modifica la variable original  </li> <li>En Java, los tipos primitivos (byte, short, int, long, float, double, boolean, char, e incluso String) se pasan por valor</li> <li>Por referencia: El m\u00e9todo puede modificar la variable original</li> <li>En Java, los objetos se pasan por referencia. Lo veremos m\u00e1s adelante.</li> </ul>"},{"location":"U02/U02.1/#ejemplo-paso-por-valor","title":"Ejemplo paso por valor","text":"<p><pre><code>int a = 3;\nSystem.out.println(\"antes: a=\" + a);  // antes: a=3\nfuncion(a);\nSystem.out.println(\"despu\u00e9s: a=\" + a);  // despu\u00e9s: a=3\n\npublic static void funcion(int x) {\n  x = 5;\n  System.out.println(\"dentro: a=\" + x); // dentro: a=5\n}\n</code></pre> - La variable <code>a</code> no se modifica</p>"},{"location":"U02/U02.1/#comparativa-paso-por-valor-vs-referencia","title":"Comparativa paso por valor vs referencia","text":"Mecanismo Explicaci\u00f3n Implicaciones Ventaja Por valor Se pasa una copia No se modifica el original Protege la variable Por referencia Se pasa la direcci\u00f3n Se puede modificar Permite devolver valores como argumentos"},{"location":"U02/U02.1/#8-metodos-sobrecargados","title":"8. M\u00e9todos sobrecargados","text":""},{"location":"U02/U02.1/#ejemplo_2","title":"Ejemplo","text":"<ul> <li>Mismo nombre, diferente n\u00famero/tipo de argumentos  </li> </ul> <pre><code>int suma(int a, int b) {\n  return a + b;\n}\n\nint suma(int a, int b, int c) {\n  return a + b + c;\n}\n</code></pre>"},{"location":"U02/U02.1/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<ul> <li>Podemos llamar al m\u00e9todo que queramos seg\u00fan los argumentos que le pasemos</li> </ul> <pre><code>public static void main(String[] args) {\n  int x = suma(5, 10);  // llama al primer m\u00e9todo y vale 15\n  int y = suma(5, 10, 15);  // llama al segundo m\u00e9todo y vale 30\n}\n</code></pre>"},{"location":"U02/U02.1/#9-ambito-de-definicion-de-metodos","title":"9. \u00c1mbito de definici\u00f3n de m\u00e9todos","text":"<ul> <li>Par\u00e1metros y variables locales son accesibles solo dentro del m\u00e9todo  </li> <li>Una clase puede definir y usar sus propios m\u00e9todos  </li> <li>No hay restricciones en el orden de los m\u00e9todos. En el caso de existir m\u00e9todo <code>main</code>, puede estar en cualquier posici\u00f3n</li> </ul> <pre><code>public class Ejemplo {\n  static void metodo1() { ... }\n  static void metodo2() { ... }\n  public static void main(String[] args) { ... }\n}\n</code></pre>"},{"location":"U02/U02.1/#10-uso-de-metodos-de-otras-clases","title":"10. Uso de m\u00e9todos de otras clases","text":""},{"location":"U02/U02.1/#metodos-estaticos","title":"M\u00e9todos est\u00e1ticos","text":"<ul> <li>Podemos usar m\u00e9todos de otra clase, siempre que sean <code>static</code> (cuando veamos la POO, veremos c\u00f3mo usar m\u00e9todos no est\u00e1ticos de otras clases)</li> <li>Para usar un m\u00e9todo de otra clase, se escribe <code>NombreClase.nombreMetodo(...)</code></li> <li>Ejemplos de m\u00e9todos <code>static</code> que ya hemos usado: <code>Math.sqrt()</code>, <code>System.out.println()</code></li> </ul>"},{"location":"U02/U02.1/#implementacion","title":"Implementaci\u00f3n","text":"<pre><code>public class Matematicas {\n  public static int factorial(int n) {\n    int resultado = 1;\n    for (int i = 2; i &lt;= n; i++) resultado *= i;\n    return resultado;\n  }\n\n  public static boolean esPrimo(int n) {\n    if (n &lt;= 1) return false;\n    for (int i = 2; i &lt;= Math.sqrt(n); i++) if (n % i == 0) return false;\n    return true;\n  }\n}\n</code></pre>"},{"location":"U02/U02.1/#llamada-a-metodos-estaticos","title":"Llamada a m\u00e9todos est\u00e1ticos","text":"<pre><code>public class PruebaMatematicas {\n  public static void main(String[] args) {\n    int numero = 5;\n    System.out.println(\"Factorial de \" + numero + \": \" + Matematicas.factorial(numero));\n    System.out.println(numero + \" es primo: \" + Matematicas.esPrimo(numero));\n  }\n}\n</code></pre>"},{"location":"U02/U02.2/","title":"2.2 - Strings","text":""},{"location":"U02/U02.2/#strings","title":"Strings","text":""},{"location":"U02/U02.2/#unidad-22","title":"Unidad 2.2","text":""},{"location":"U02/U02.2/#contenidos","title":"Contenidos","text":"<ol> <li>\u00bfQu\u00e9 es un String?</li> <li>length()</li> <li>charAt()</li> <li>substring()</li> <li>toUpperCase() / toLowerCase()</li> <li>equals() / equalsIgnoreCase()</li> <li>contains()</li> <li>indexOf()</li> <li>replace()</li> <li>trim()</li> <li>compareTo() / compareToIgnoreCase()</li> <li>Transformaciones entre tipos</li> </ol>"},{"location":"U02/U02.2/#1-que-es-un-string","title":"1. \u00bfQu\u00e9 es un String?","text":"<ul> <li>Un <code>String</code> es una secuencia de caracteres.  </li> <li>En Java, es un objeto de la clase <code>String</code>.</li> </ul> <p>Ejemplos</p> <pre><code>String saludo = \"Hola mundo\";\nString nombre = new String(\"Alejandro\");\n</code></pre>"},{"location":"U02/U02.2/#2-length","title":"2. length()","text":"<ul> <li><code>length()</code>: Devuelve la longitud del String.</li> </ul> <pre><code>String texto = \"Java\";\nSystem.out.println(texto.length()); // 4\n</code></pre>"},{"location":"U02/U02.2/#3-charatint-index","title":"3. charAt(int index)","text":"<ul> <li><code>charAt(int index)</code>: Devuelve el car\u00e1cter en la posici\u00f3n indicada (comenzando en 0).</li> </ul> <pre><code>String texto = \"Java\";\nSystem.out.println(texto.charAt(1)); // 'a'\n</code></pre>"},{"location":"U02/U02.2/#4-substringint-beginindex-substringint-beginindex-int-endindex","title":"4. substring(int beginIndex) / substring(int beginIndex, int endIndex)","text":"<ul> <li><code>substring(int beginIndex)</code>: extrae desde una posici\u00f3n hasta el final.</li> <li><code>substring(int beginIndex, int endIndex)</code>: extrae entre dos posiciones (begin inclusive, end exclusive).</li> </ul> <pre><code>String texto = \"Programaci\u00f3n\";\nSystem.out.println(texto.substring(6)); // \"maci\u00f3n\"\nSystem.out.println(texto.substring(0, 6)); // \"Progra\"\n</code></pre>"},{"location":"U02/U02.2/#5-touppercase-tolowercase","title":"5. toUpperCase() / toLowerCase()","text":"<ul> <li><code>toUpperCase()</code>: convierte todos los caracteres a may\u00fasculas.</li> <li><code>toLowerCase()</code>: convierte todos los caracteres a min\u00fasculas.</li> </ul> <pre><code>String texto1 = \"java\";\nSystem.out.println(texto1.toUpperCase()); // \"JAVA\"\n\nString texto2 = \"JAVA\";\nSystem.out.println(texto2.toLowerCase()); // \"java\"\n</code></pre>"},{"location":"U02/U02.2/#6-equalsstring-otro-equalsignorecasestring-otro","title":"6. equals(String otro) / equalsIgnoreCase(String otro)","text":"<ul> <li><code>equals(String otro)</code>: compara contenido (sensible a may\u00fasculas).  </li> <li><code>equalsIgnoreCase(String otro)</code>: compara ignorando may\u00fasculas.</li> </ul> <pre><code>String a = \"Hola\";\nString b = \"hola\";\nSystem.out.println(a.equals(b)); // false\nSystem.out.println(a.equalsIgnoreCase(b)); // true\n</code></pre>"},{"location":"U02/U02.2/#7-containsstring-subcadena","title":"7. contains(String subcadena)","text":"<ul> <li><code>contains(String subcadena)</code>: verifica si contiene una subcadena.</li> </ul> <pre><code>String texto = \"Programaci\u00f3n\";\nSystem.out.println(texto.contains(\"grama\")); // true\nSystem.out.println(texto.contains(\"Java\")); // false\n</code></pre>"},{"location":"U02/U02.2/#8-indexofstring-subcadena","title":"8. indexOf(String subcadena)","text":"<ul> <li><code>indexOf(String subcadena)</code>: devuelve la posici\u00f3n de la primera aparici\u00f3n de la subcadena (o -1 si no existe).</li> </ul> <pre><code>String texto = \"Programaci\u00f3n\";\nSystem.out.println(texto.indexOf(\"a\")); // 5\nSystem.out.println(texto.indexOf(\"z\")); // -1\n</code></pre>"},{"location":"U02/U02.2/#9-replacechar-viejo-char-nuevo-replacestring-viejo-string-nuevo","title":"9. replace(char viejo, char nuevo) / replace(String viejo, String nuevo)","text":"<ul> <li><code>replace()</code>: reemplaza caracteres o subcadenas.</li> </ul> <pre><code>String texto1 = \"casa\";\nSystem.out.println(texto1.replace('a', 'o')); // \"coso\"\n\nSystem.out.println(\"hola mundo\".replace(\"mundo\", \"Java\")); // \"hola Java\"\n</code></pre>"},{"location":"U02/U02.2/#10-trim","title":"10. trim()","text":"<ul> <li><code>trim()</code>: elimina espacios al inicio y al final.</li> </ul> <pre><code>String texto2 = \"  hola  \";\nSystem.out.println(texto2.trim()); // \"hola\"\n</code></pre>"},{"location":"U02/U02.2/#11-comparetostring-otro-comparetoignorecasestring-otro","title":"11. compareTo(String otro) / compareToIgnoreCase(String otro)","text":"<ul> <li><code>compareTo(String otro)</code>: compara lexicogr\u00e1ficamente; devuelve &lt;0 si este &lt; otro, 0 si iguales, &gt;0 si este &gt; otro.</li> <li><code>compareToIgnoreCase(String otro)</code>: igual que <code>compareTo</code> pero ignorando may\u00fasculas/min\u00fasculas.</li> </ul> <pre><code>String a = \"abc\";\nString b = \"bcd\";\nSystem.out.println(a.compareTo(b)); // negativo (por 'a' &lt; 'b')\nSystem.out.println(a.compareTo(\"abc\")); // 0\n\nString x = \"Hola\";\nString y = \"hola\";\nSystem.out.println(x.compareTo(y)); // distinto de 0 (sensible a may\u00fasculas)\nSystem.out.println(x.compareToIgnoreCase(y)); // 0\n</code></pre>"},{"location":"U02/U02.2/#12-transformaciones-entre-tipos","title":"12. Transformaciones entre tipos","text":"Primitivo \u2192 String String \u2192 Primitivo int: <code>Integer.toString(n)</code>, <code>String.valueOf(n)</code>, <code>\"\" + n</code> int: <code>Integer.parseInt(s)</code> char: <code>Character.toString(c)</code>, <code>String.valueOf(c)</code>, <code>\"\" + c</code> char: <code>s.charAt(0)</code> boolean: <code>Boolean.toString(b)</code>, <code>String.valueOf(b)</code> boolean: <code>Boolean.parseBoolean(s)</code> float: <code>Float.toString(f)</code>, <code>String.valueOf(f)</code> float: <code>Float.parseFloat(s)</code> <pre><code>int n = 123;\n// Transformar de int a String\nString s1 = Integer.toString(n);     // \"123\"\nString s2 = String.valueOf(n);       // \"123\"\nString s3 = \"\" + n;                  // \"123\"\n\n// Transformar de char a String\nchar c = \"hola\".charAt(0);            // 'h'\nString cs = Character.toString(c);   // \"h\"\n\n// Transformar de String a int\nString numText = \"456\";\nint m = Integer.parseInt(numText);   // 456\n</code></pre>"},{"location":"U03/U03.1/","title":"3.1 - Arrays","text":""},{"location":"U03/U03.1/#arrays","title":"Arrays","text":""},{"location":"U03/U03.1/#unidad-31","title":"Unidad 3.1","text":""},{"location":"U03/U03.1/#contenidos","title":"Contenidos","text":"<ol> <li>\u00bfQu\u00e9 es un array?</li> <li>Declaraci\u00f3n y creaci\u00f3n</li> <li>Acceso</li> <li>Recorrido</li> <li>Paso por referencia en m\u00e9todos</li> <li>Copia de arrays</li> <li>M\u00e9todos \u00fatiles</li> <li>Arrays multidimensionales</li> </ol>"},{"location":"U03/U03.1/#1-que-es-un-array","title":"1. \u00bfQu\u00e9 es un array?","text":"<ul> <li>Estructura que almacena una serie de elementos del mismo tipo</li> <li>Acceso por \u00edndice entero (empieza en 0)</li> <li>Tama\u00f1o fijo: se decide al crearlo</li> <li>Puede contener tipos primitivos o complejos (objetos, los veremos m\u00e1s adelante)</li> <li>Acceder fuera de rango lanza una excepci\u00f3n <code>ArrayIndexOutOfBoundsException</code></li> </ul>"},{"location":"U03/U03.1/#tipos-de-arrays","title":"Tipos de arrays","text":"<ul> <li>Arrays unidimensionales (vectores)</li> <li>Arrays multidimensionales (matrices)</li> <li>En Java son \u201carrays de arrays\u201d</li> </ul>"},{"location":"U03/U03.1/#arrays-vs-listas","title":"Arrays vs listas","text":"<ul> <li>Arrays: tama\u00f1o fijo</li> <li>Si no se conoce el tama\u00f1o estamos obligados a sobredimensionar o redimensionar (crear otro array y copiar)</li> <li>Listas (List): tama\u00f1o variable</li> <li>Alternativa flexible cuando crece din\u00e1micamente (veremos m\u00e1s adelante)</li> </ul>"},{"location":"U03/U03.1/#2-declaracion-y-creacion","title":"2. Declaraci\u00f3n y creaci\u00f3n","text":"<ul> <li> <p>Declarar variable array <pre><code>int[] numeros;         // recomendado en Java\nint numerosC[];        // estilo C (v\u00e1lido pero menos claro)\n</code></pre> Ahora debemos entender el <code>String[] args</code> del m\u00e9todo <code>main</code></p> </li> <li> <p>Crear (instanciar) el array <pre><code>numeros = new int[4];\n</code></pre></p> </li> <li> <p>Declarar + crear <pre><code>int[] datos = new int[7];\n</code></pre></p> </li> <li> <p>Inicializar el array manualmente (asignando por \u00edndice) <pre><code>datos[0] = 10;\ndatos[1] = -3;\ndatos[2] = 7;\ndatos[3] = 0;\ndatos[4] = 42;\ndatos[5] = 5;\ndatos[6] = 9;\n</code></pre></p> </li> <li> <p>Si deseamos inicializar al declararlo, podemos usar llaves <code>{}</code>: <pre><code>int[] v = {2, -4, 15, -25};\nchar[] letras = {'a','b','c'};\nString[] nombres = {\"Ana\",\"Luis\",\"Eva\"};\n</code></pre></p> </li> <li> <p>Valores por defecto si no se inicializa:</p> </li> <li>num\u00e9ricos \u2192 0</li> <li>booleanos \u2192 false</li> <li>objetos (de momento, String) \u2192 null</li> </ul>"},{"location":"U03/U03.1/#3-acceso","title":"3. Acceso","text":"<ul> <li> <p>Lectura <pre><code>int x = v[2];\nSystem.out.println(v[3]);\n</code></pre></p> </li> <li> <p>Escritura <pre><code>v[0] = 99;\n</code></pre></p> </li> <li> <p>Longitud <pre><code>int n = v.length; // n\u00famero de elementos\n</code></pre></p> </li> </ul>"},{"location":"U03/U03.1/#4-recorrido","title":"4. Recorrido","text":""},{"location":"U03/U03.1/#for-clasico","title":"for cl\u00e1sico","text":"<pre><code>int[] datos = {1, 2, 3, 4};\n\nfor (int i = 0; i &lt; datos.length; i++) {\n  System.out.print(datos[i] + \" \");\n}\n</code></pre> <ul> <li>Control total sobre \u00edndices</li> <li>\u00datil cuando se necesita la posici\u00f3n</li> </ul>"},{"location":"U03/U03.1/#for-each","title":"for-each","text":"<pre><code>int[] datos = {1, 2, 3, 4};\n\nfor (int d : datos) {\n  System.out.print(d + \" \");\n}\n</code></pre> <ul> <li>M\u00e1s simple para leer todos los elementos</li> <li>No expone el \u00edndice</li> </ul>"},{"location":"U03/U03.1/#ejemplo-calculo-del-maximo-de-un-array","title":"Ejemplo: c\u00e1lculo del m\u00e1ximo de un array","text":"<pre><code>int max1 = Integer.MIN_VALUE; // valor m\u00ednimo posible de un int\n// for cl\u00e1sico\nfor (int i = 0; i &lt; v.length; i++) {\n  if (v[i] &gt; max1) max1 = v[i];\n}\n\nint max2 = Integer.MIN_VALUE; // valor m\u00ednimo posible de un int\n// for-each\nfor (int n : v) {\n  if (n &gt; max2) max2 = n;\n}\n</code></pre>"},{"location":"U03/U03.1/#5-paso-por-referencia-en-metodos","title":"5. Paso por referencia en m\u00e9todos","text":"<ul> <li>Al pasar un array a un m\u00e9todo, se pasa una referencia al mismo objeto</li> <li>El m\u00e9todo puede modificar el contenido del array compartido</li> </ul> <pre><code>// Implementaci\u00f3n de un m\u00e9todo que modifica un array\nvoid multiplicaPrimeroPor10(int[] x) {\n  x[0] *= 10;\n}\n\n// Uso del m\u00e9todo\nint[] a = {1, 2, 3};\nmultiplicaPrimeroPor10(a); // a =&gt; [10, 2, 3]\n</code></pre>"},{"location":"U03/U03.1/#6-copia-de-arrays","title":"6. Copia de arrays","text":"<ul> <li> <p>Asignaci\u00f3n copia la referencia (se comparte el mismo array en memoria) <pre><code>int[] a = {1, 2, 3};\nint[] b = a;      // b y a apuntan al mismo array\na[0] = 10;        // b[0] tambi\u00e9n es 10\n</code></pre></p> </li> <li> <p>Clonado crea otro array con los mismos valores (primitivos) <pre><code>int[] a = {1, 2, 3};\nint[] b = a.clone(); // copia independiente\na[0] = 10;           // b sigue siendo [1, 2, 3]\n</code></pre></p> </li> <li> <p>Copia profunda. Equivalente a clonar pero copiando los valores manualmente</p> </li> </ul> <pre><code>int[] a = {1, 2, 3};\nint[] b = new int[a.length];\nfor (int i = 0; i &lt; a.length; i++) {\n  b[i] = a[i]; // nuevo valor\n}\n</code></pre>"},{"location":"U03/U03.1/#7-metodos-utiles","title":"7. M\u00e9todos \u00fatiles","text":"<ul> <li>Se encuentran en la clase <code>Arrays</code> del paquete <code>java.util</code>. Hay que importarla:</li> </ul> <pre><code>import java.util.Arrays;\n</code></pre> <ul> <li> <p>length. Devuelve la cantidad de elementos en el array. Se trata de una propiedad, por lo que no lleva par\u00e9ntesis como los m\u00e9todos.   <pre><code>int[] a = {1, 2, 3, 4};\nSystem.out.println(a.length); // Salida: 4\n</code></pre></p> </li> <li> <p>Arrays.toString(a). Convierte el array <code>a</code> en una representaci\u00f3n de cadena, \u00fatil para imprimir el contenido del array de forma legible.   <pre><code>int[] a = {1, 2, 3, 4};\nSystem.out.println(Arrays.toString(a)); // Salida: [1, 2, 3, 4]\n</code></pre></p> </li> <li> <p>Arrays.sort(a). Ordena el array <code>a</code> en orden ascendente. Modifica el array original.   <pre><code>int[] a = {4, 2, 3, 1};\nArrays.sort(a);\nSystem.out.println(Arrays.toString(a)); // Salida: [1, 2, 3, 4]\n</code></pre></p> </li> <li> <p>Arrays.binarySearch(a). Realiza una b\u00fasqueda binaria en el array <code>a</code>. Debe estar ordenado previamente para que funcione.   <pre><code>int[] a = {1, 2, 3, 4};\nint index = Arrays.binarySearch(a, 3);\nSystem.out.println(index); // Salida: 2\n</code></pre></p> </li> <li> <p>Arrays.equals(a, b). Compara dos arrays <code>a</code> y <code>b</code> para verificar si son iguales en contenido y longitud.   <pre><code>int[] a = {1, 2, 3};\nint[] b = {1, 2, 3};\nSystem.out.println(Arrays.equals(a, b)); // Salida: true\n</code></pre></p> </li> <li> <p>Arrays.fill(a, valor). Rellena el array <code>a</code> con el valor especificado. Todos los elementos del array se establecen en <code>valor</code>.   <pre><code>int[] a = new int[5];\nArrays.fill(a, 10);\nSystem.out.println(Arrays.toString(a)); // Salida: [10, 10, 10, 10, 10]\n</code></pre></p> </li> <li> <p>Arrays.copyOf(a, nuevoTam). Crea una copia del array <code>a</code> con un nuevo tama\u00f1o <code>nuevoTam</code>. Si el nuevo tama\u00f1o es mayor, se rellenan los nuevos elementos con <code>null</code> (para arrays de objetos) o <code>0</code> (para arrays de primitivos).   <pre><code>int[] a = {1, 2, 3};\nint[] b = Arrays.copyOf(a, 5);\nSystem.out.println(Arrays.toString(b)); // Salida: [1, 2, 3, 0, 0]\n</code></pre></p> </li> <li> <p>cadena.split(delimitador): pertenece a la clase <code>String</code> (no a <code>Arrays</code>), pero tiene mucha relaci\u00f3n con arrays, ya que divide una cadena en un array de cadenas usando un delimitador (separador)</p> </li> <li>Sintaxis: <code>String[] resultado = cadena.split(delimitador);</code></li> </ul> <pre><code>String texto = \"Ana,Luis,Eva,Pedro\";\nString[] nombres = texto.split(\",\");\nSystem.out.println(Arrays.toString(nombres)); \n// Salida: [Ana, Luis, Eva, Pedro]\n</code></pre> <pre><code>String frase = \"Java es un lenguaje potente\";\nString[] palabras = frase.split(\" \");\n\nfor (String palabra : palabras) {\n  System.out.println(palabra);\n}\n// Salida:\n// Java\n// es\n// un\n// lenguaje\n// potente\n</code></pre>"},{"location":"U03/U03.1/#8-arrays-multidimensionales-2d","title":"8. Arrays multidimensionales (2D)","text":"<ul> <li>Arrays 2D: tabla o matriz (filas x columnas)</li> <li>En Java se representa como array de arrays</li> </ul> <pre><code>int[][] m = new int[3][4]; // 3 filas, 4 columnas\nm[2][1] = 24;\n</code></pre> m Col 0 Col 1 Col 2 Col 3 tama\u00f1o fila i Fila 0 0 0 0 0 <code>m[0].length // 4</code> Fila 1 0 0 0 0 <code>m[1].length // 4</code> Fila 2 0 24 0 0 <code>m[2].length // 4</code> <ul> <li>Longitudes: al ser un array de arrays, cada fila tiene su propia longitud <pre><code>// tama\u00f1o: filas (3) x columnas (4)\nm.length        // filas (3)\nm[0].length     // columnas de la fila 0 (4)\nm[1].length     // columnas de la fila 1 (4)\nm[2].length     // columnas de la fila 2 (4)\n</code></pre></li> </ul>"},{"location":"U03/U03.1/#matrices-irregulares","title":"Matrices irregulares","text":"<ul> <li>En Java, las matrices pueden tener filas de diferentes longitudes</li> </ul> <p><pre><code>int[][] b = new int[2][];  // declaraci\u00f3n de 2 filas sin especificar columnas\nb[0] = new int[3];         // primera fila con 3 columnas\nb[1] = new int[5];         // segunda fila con 5 columnas\n</code></pre> | b      | Col 0 | Col 1 | Col 2 | Col 3 | Col 4 | tama\u00f1o fila i | |--------|-------|-------|-------|-------|-------|------------------| | Fila 0 | 0     | 0     | 0     | \u2014     | \u2014     | <code>b[0].length // 3</code>  | | Fila 1 | 0     | 0     | 0     | 0     | 0     | <code>b[1].length // 5</code>  |</p>"},{"location":"U03/U03.1/#matrices-irregulares_1","title":"Matrices irregulares","text":"<p><pre><code>int[][] c = {\n  {10, 20},\n  {30, 40, 50, 60},\n  {70}\n};\n</code></pre> | c      | Col 0 | Col 1 | Col 2 | Col 3 | tama\u00f1o fila i | |--------|-------|-------|-------|-------|------------------| | Fila 0 | 10    | 20    | \u2014     | \u2014     | <code>c[0].length // 2</code>  | | Fila 1 | 30    | 40    | 50    | 60    | <code>c[1].length // 4</code>  | | Fila 2 | 70    | \u2014     | \u2014     | \u2014     | <code>c[2].length // 1</code>  |</p>"},{"location":"U03/U03.1/#recorridos","title":"Recorridos","text":"<p><pre><code>double[][] m = {\n  {1,2,3,4,5},\n  {6,7,8,9,10,11,12}\n};\n</code></pre> - for cl\u00e1sico <pre><code>for (int i = 0; i &lt; m.length; i++) {\n  for (int j = 0; j &lt; m[i].length; j++)\n    System.out.print(m[i][j] + \"\\t\");\n  System.out.println();\n}\n</code></pre></p>"},{"location":"U03/U03.1/#recorridos_1","title":"Recorridos","text":"<ul> <li>for-each</li> </ul> <pre><code>for (double[] fila : m) {\n  for (double dato : fila)\n    System.out.print(dato + \" \");\n  System.out.println();\n}\n</code></pre>"},{"location":"U03/U03.1/#ejemplo-matriz-identidad-4x4","title":"Ejemplo: matriz identidad 4x4","text":"<pre><code>double[][] I = new double[4][4];\n\n// Inicializar matriz identidad\nfor (int i = 0; i &lt; I.length; i++)\n  for (int j = 0; j &lt; I[i].length; j++) \n    I[i][j] = (i == j) ? 1.0 : 0.0;\n\n// Imprimir matriz identidad\nfor (int i = 0; i &lt; I.length; i++) {\n  for (int j = 0; j &lt; I[i].length; j++)\n    System.out.print(I[i][j] + \"\\t\");\n  System.out.println();\n}\n</code></pre>"},{"location":"U03/U03.1/#generalizacion-a-n-dimensiones","title":"Generalizaci\u00f3n a N dimensiones","text":"<pre><code>// Total de elementos = producto de tama\u00f1os\n// tama\u00f1o1 * tama\u00f1o2 * ... * tama\u00f1oN\nint[][][] t = new int[2][3][4]; // 2*3*4 = 24\n</code></pre>"}]}